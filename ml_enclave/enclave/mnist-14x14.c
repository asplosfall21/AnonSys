// This file is computer-generated by onnx2c 
// (TODO: add creating command line here)
// (TODO: print creation date here )

// ONNX model:
// produced by pytorch, version 1.7
// ONNX IR version: 9
// Model documentation: 
/*

*/

#include <float.h>
#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <string.h>
#include "ttp_enclave_util.h"
#define MAX(X,Y) ( X > Y ? X : Y)
#define MIN(X,Y) ( X < Y ? X : Y)
#define CLIP(X,L) ( MAX(MIN(X,L), -L) )

const float (*tensor_cnn1_weight)[20][1][5][5];
const float (*tensor_cnn2_weight)[12][20][3][3]; 
const float (*tensor_linear_bias)[10]; 
const float (*tensor_linear_weight)[10][108];
static const int64_t tensor_14[2] = {1, -1};

void mnist_14x14_init(uintptr_t tensor_cnn1_weight_ptr, uintptr_t tensor_cnn2_weight_ptr, uintptr_t tensor_linear_bias_ptr, uintptr_t tensor_linear_weight_ptr, uintptr_t tensor_14_ptr) {
  tensor_cnn1_weight = (void *)tensor_cnn1_weight_ptr; 
  tensor_cnn2_weight = (void *)tensor_cnn2_weight_ptr; 
  tensor_linear_bias = (void *)tensor_linear_bias_ptr; 
  tensor_linear_weight = (void *)tensor_linear_weight_ptr; 
}

union tensor_union_0 {
float tensor_8[1][20][5][5];
float tensor_10[1][12][3][3];
};
static union tensor_union_0 tu0;

union tensor_union_1 {
float tensor_9[1][20][5][5];
float tensor_15[1][108];
};
static union tensor_union_1 tu1;


static inline void node_Conv_3( const float x[1][1][14][14], const float w[20][1][5][5], float y[1][20][5][5] )
{
	/* Conv
	 *
	 * auto_pad: NOTSET
	 * dilations: 1 1 
	 * group: 1
	 * kernel_shape: 5 5 
	 * pads: 0 0 0 0 
	 * strides: 2 2 
	 */
	for( uint32_t b=0; b<1; b++ ) {
	for( uint32_t m=0; m<20; m++) {
		for( int32_t o0=0, i0=0; o0<5; o0++, i0+=2) {
		for( int32_t o1=0, i1=0; o1<5; o1++, i1+=2) {
			y[b][m][o0][o1] = 0;
			for( int32_t c=0; c<1; c++ ) {
			for( uint32_t k0=0; k0<5; k0++ ) {
			for( uint32_t k1=0; k1<5; k1++ ) {
				int ii0 = i0+k0 * 1;
				if( ii0<0) continue;
				if( ii0>=14) continue;
				int ii1 = i1+k1 * 1;
				if( ii1<0) continue;
				if( ii1>=14) continue;
				y[b][m][o0][o1] += x[b][c][ii0][ii1] *w[m][c][k0][k1];
			} /* k */
			} /* k */
			} /* c */
		} /* o */
		} /* o */
	} /* m */
	} /* b */
}

static inline void node_Relu_4( const float X[1][20][5][5], float Y[1][20][5][5] )
{
	/*Relu*/
	float *X_ptr = (float*)X;
	float *Y_ptr = (float*)Y;
	for( uint32_t i=0; i<500; i++ )
		Y_ptr[i] = X_ptr[i] > 0 ? X_ptr[i] : 0;

}

static inline void node_Conv_5( const float x[1][20][5][5], const float w[12][20][3][3], float y[1][12][3][3] )
{
	/* Conv
	 *
	 * auto_pad: NOTSET
	 * dilations: 1 1 
	 * group: 1
	 * kernel_shape: 3 3 
	 * pads: 0 0 0 0 
	 * strides: 1 1 
	 */
	for( uint32_t b=0; b<1; b++ ) {
	for( uint32_t m=0; m<12; m++) {
		for( int32_t o0=0, i0=0; o0<3; o0++, i0+=1) {
		for( int32_t o1=0, i1=0; o1<3; o1++, i1+=1) {
			y[b][m][o0][o1] = 0;
			for( int32_t c=0; c<20; c++ ) {
			for( uint32_t k0=0; k0<3; k0++ ) {
			for( uint32_t k1=0; k1<3; k1++ ) {
				int ii0 = i0+k0 * 1;
				if( ii0<0) continue;
				if( ii0>=5) continue;
				int ii1 = i1+k1 * 1;
				if( ii1<0) continue;
				if( ii1>=5) continue;
				y[b][m][o0][o1] += x[b][c][ii0][ii1] *w[m][c][k0][k1];
			} /* k */
			} /* k */
			} /* c */
		} /* o */
		} /* o */
	} /* m */
	} /* b */
}

static inline void node_Reshape_8( const float data[1][12][3][3], const int64_t shape[2], float reshaped[1][108] )
{
	/*Reshape*/
	float *data_ptr = (float*)data;
	float *reshaped_ptr = (float*)reshaped;
	for( uint32_t i=0; i<108; i++ )
		reshaped_ptr[i] = data_ptr[i];

}

static inline void node_Gemm_9( const float A[1][108], const float B[10][108], const float C[10], float Y[1][10] )
{
	/* Gemm */
	/* alpha   = 1.0000000000000000000
	   beta    = 1.0000000000000000000
	   transA  = 0
	   transB  = 1
	 */
	const int M = 1;
	const int K = 108;
	const int N = 10;
	float alpha = 1.0000000000000000000;
	float beta = 1.0000000000000000000;
	float (*C_)[10]  = (float(*)[10])C;
	for( uint32_t r=0; r<M; r++ )
		for( uint32_t c=0; c<N; c++ ) {
			float ABrc = 0;
			for( uint32_t i=0; i<K; i++ ) {
				float B_el = B[c][i];
				ABrc += A[r][i] * B_el;
			}
			float tmp = ABrc * alpha;
			tmp += C_[0][c] * beta;
			Y[r][c] = tmp;
	}
}


void entry(const float tensor_network_input[1][1][14][14], float tensor_network_output[1][10]) {

	volatile float a = (*tensor_cnn1_weight)[0][0][0][0];
	volatile float b = (*tensor_cnn2_weight)[0][0][0][0];
	volatile float c = (*tensor_linear_bias)[0];
	volatile float d = (*tensor_linear_weight)[0][0];

  platform_disable_predictors();
	node_Conv_3( tensor_network_input, *tensor_cnn1_weight, tu0.tensor_8);
	node_Relu_4( tu0.tensor_8, tu1.tensor_9);
	node_Conv_5( tu1.tensor_9, *tensor_cnn2_weight, tu0.tensor_10);
	node_Reshape_8( tu0.tensor_10, tensor_14, tu1.tensor_15);
	node_Gemm_9( tu1.tensor_15, *tensor_linear_weight, *tensor_linear_bias, tensor_network_output);
  platform_enable_predictors();
}
